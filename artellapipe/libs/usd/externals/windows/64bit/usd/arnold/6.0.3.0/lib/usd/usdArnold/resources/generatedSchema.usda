#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED.  DO NOT EDIT."
    customLayerData = {
        string[] appliedAPISchemas = ["ArnoldLightAPI", "ArnoldShapeAPI", "ArnoldDistantLightAPI", "ArnoldQuadLightAPI", "ArnoldSkydomeLightAPI", "ArnoldDiskLightAPI", "ArnoldMeshLightAPI", "ArnoldSphereAPI", "ArnoldCylinderAPI", "ArnoldConeAPI", "ArnoldPolymeshAPI", "ArnoldBoxAPI", "ArnoldCurvesAPI", "ArnoldPointsAPI"]
        string[] multipleApplyAPISchemas = []
    }
)

class ArnoldColorManager "ArnoldColorManager"
{
    string color_space_linear = ""
    string color_space_narrow = ""
    string config = ""
    float[] linear_chromaticities
}

class ArnoldLight "ArnoldLight" (
    apiSchemas = ["CollectionAPI:lightLink", "CollectionAPI:shadowLink"]
)
{
    string aov = "default"
    bool cast_shadows = 1
    bool cast_volumetric_shadows = 1
    uniform bool collection:lightLink:includeRoot = 1
    uniform bool collection:shadowLink:includeRoot = 1
    color3f color = (1, 1, 1) (
        doc = "The color of emitted light, in energy-linear terms."
    )
    float colorTemperature = 6500 (
        displayName = "Color Temperature"
        doc = """Color temperature, in degrees Kelvin, representing the\r
        white point.  The default is a common white point, D65.  Lower\r
        values are warmer and higher values are cooler.  The valid range\r
        is from 1000 to 10000. Only takes effect when\r
        enableColorTemperature is set to true.  When active, the\r
        computed result multiplies against the color attribute.\r
        See UsdLuxBlackbodyTemperatureAsRgb()."""
    )
    float diffuse = 1 (
        displayName = "Diffuse Multiplier"
        doc = """A multiplier for the effect of this light on the diffuse\r
        response of materials.  This is a non-physical control."""
    )
    bool enableColorTemperature = 0 (
        displayName = "Enable Color Temperature"
        doc = "Enables using colorTemperature."
    )
    float exposure = 0 (
        doc = """Scales the power of the light exponentially as a power\r
        of 2 (similar to an F-stop control over exposure).  The result\r
        is multiplied against the intensity."""
    )
    rel filters (
        doc = "Relationship to the light filters that apply to this light."
    )
    float indirect = 1
    float intensity = 1 (
        doc = "Scales the power of the light linearly."
    )
    matrix4d[] matrix
    int max_bounces = 999
    float motion_end = 1
    float motion_start = 0
    bool normalize = 1 (
        displayName = "Normalize Power"
        doc = """Normalizes power by the surface area of the light.\r
        This makes it easier to independently adjust the power and shape\r
        of the light, by causing the power to not vary with the area or\r
        angular size of the light."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    int samples = 1
    color3f shadow_color = (0, 0, 0)
    float shadow_density = 1
    float specular = 1 (
        displayName = "Specular Multiplier"
        doc = """A multiplier for the effect of this light on the specular\r
        response of materials.  This is a non-physical control."""
    )
    float sss = 1
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float volume = 1
    int volume_samples = 2
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class "ArnoldLightAPI"
{
    string primvars:arnold:aov = "default"
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class ArnoldDriver "ArnoldDriver"
{
}

class ArnoldFilter "ArnoldFilter"
{
}

class ArnoldOperator "ArnoldOperator"
{
    bool enable = 1
}

class ArnoldShape "ArnoldShape"
{
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    float motion_end = 1
    float motion_start = 0
    bool opaque = 1
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar sidedness = 255
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class "ArnoldShapeAPI"
{
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    uchar primvars:arnold:sidedness = 255
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
}

class ArnoldCamera "ArnoldCamera"
{
    float4[] clippingPlanes = [] (
        doc = """Additional, arbitrarily oriented clipping planes.\r
                 A vector (a,b,c,d) encodes a clipping plane that cuts off\r
                 (x,y,z) with a * x + b * y + c * z + d * 1 < 0 where (x,y,z)\r
                 are the coordinates in the camera's space."""
    )
    float2 clippingRange = (1, 1000000) (
        doc = """Near and far clipping distances in centimeters (or, more\r
                 general, world units)."""
    )
    float exposure = 0
    float far_clip = 1e30
    float focalLength = 50 (
        doc = """Perspective focal length in millimeters (or, more general,\r
                 tenths of a world unit)."""
    )
    float focusDistance = 0 (
        doc = """Distance from the camera to the focus plane in centimeters (or\r
                 more general, world units)."""
    )
    float fStop = 0 (
        doc = "Lens aperture. Defaults to 0.0, which turns off focusing."
    )
    token handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    float horizontalAperture = 20.955 (
        doc = """Horizontal aperture in millimeters (or, more general, tenths\r
                 of a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float horizontalApertureOffset = 0 (
        doc = """Horizontal aperture offset in the same units as\r
                 horizontalAperture. Defaults to 0."""
    )
    vector3f[] look_at
    matrix4d[] matrix
    float motion_end = 1
    float motion_start = 0
    float near_clip = 0.0001
    vector3f[] position
    token projection = "perspective" (
        allowedTokens = ["perspective", "orthographic"]
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    token rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float rolling_shutter_duration = 0
    float2[] screen_window_max
    float2[] screen_window_min
    double shutter:close = 0 (
        doc = """Frame relative shutter close time, analogous comments from\r
                 shutter:open apply. A value greater or equal to shutter:open\r
                 should be authored, otherwise there is no exposure and a\r
                 renderer should produce a black image."""
    )
    double shutter:open = 0 (
        doc = """Frame relative shutter open time in UsdTimeCode units (negative\r
                 value indicates that the shutter opens before the current\r
                 frame time). Used for motion blur."""
    )
    float2[] shutter_curve
    float shutter_end = 0
    float shutter_start = 0
    token shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    uniform token stereoRole = "mono" (
        allowedTokens = ["mono", "left", "right"]
        doc = """If different from mono, the camera is intended to be the left\r
                 or right camera of a stereo setup."""
    )
    vector3f[] up
    float verticalAperture = 15.2908 (
        doc = """Vertical aperture in millimeters (or, more general, tenths of\r
                 a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float verticalApertureOffset = 0 (
        doc = """Vertical aperture offset in the same units as\r
                 verticalAperture. Defaults to 0."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldPerspCamera "ArnoldPerspCamera"
{
    float aperture_aspect_ratio = 1
    float aperture_blade_curvature = 0
    int aperture_blades = 0
    float aperture_rotation = 0
    float[] aperture_size
    float4[] clippingPlanes = [] (
        doc = """Additional, arbitrarily oriented clipping planes.\r
                 A vector (a,b,c,d) encodes a clipping plane that cuts off\r
                 (x,y,z) with a * x + b * y + c * z + d * 1 < 0 where (x,y,z)\r
                 are the coordinates in the camera's space."""
    )
    float2 clippingRange = (1, 1000000) (
        doc = """Near and far clipping distances in centimeters (or, more\r
                 general, world units)."""
    )
    float exposure = 0
    float far_clip = 1e30
    bool flat_field_focus = 1
    float focalLength = 50 (
        doc = """Perspective focal length in millimeters (or, more general,\r
                 tenths of a world unit)."""
    )
    float[] focus_distance
    float focusDistance = 0 (
        doc = """Distance from the camera to the focus plane in centimeters (or\r
                 more general, world units)."""
    )
    float[] fov
    float fStop = 0 (
        doc = "Lens aperture. Defaults to 0.0, which turns off focusing."
    )
    token handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    float horizontalAperture = 20.955 (
        doc = """Horizontal aperture in millimeters (or, more general, tenths\r
                 of a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float horizontalApertureOffset = 0 (
        doc = """Horizontal aperture offset in the same units as\r
                 horizontalAperture. Defaults to 0."""
    )
    float2[] lens_shift
    float2[] lens_tilt_angle
    vector3f[] look_at
    matrix4d[] matrix
    float motion_end = 1
    float motion_start = 0
    float near_clip = 0.0001
    bool plane_distance = 1
    vector3f[] position
    token projection = "perspective" (
        allowedTokens = ["perspective", "orthographic"]
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float radial_distortion = 0
    token radial_distortion_type = "cubic" (
        allowedTokens = ["cubic", "cubic_inverse"]
    )
    token rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float rolling_shutter_duration = 0
    float2[] screen_window_max
    float2[] screen_window_min
    double shutter:close = 0 (
        doc = """Frame relative shutter close time, analogous comments from\r
                 shutter:open apply. A value greater or equal to shutter:open\r
                 should be authored, otherwise there is no exposure and a\r
                 renderer should produce a black image."""
    )
    double shutter:open = 0 (
        doc = """Frame relative shutter open time in UsdTimeCode units (negative\r
                 value indicates that the shutter opens before the current\r
                 frame time). Used for motion blur."""
    )
    float2[] shutter_curve
    float shutter_end = 0
    float shutter_start = 0
    token shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    uniform token stereoRole = "mono" (
        allowedTokens = ["mono", "left", "right"]
        doc = """If different from mono, the camera is intended to be the left\r
                 or right camera of a stereo setup."""
    )
    vector3f[] up
    color4f uv_remap = (0, 0, 0, 0)
    float verticalAperture = 15.2908 (
        doc = """Vertical aperture in millimeters (or, more general, tenths of\r
                 a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float verticalApertureOffset = 0 (
        doc = """Vertical aperture offset in the same units as\r
                 verticalAperture. Defaults to 0."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldOrthoCamera "ArnoldOrthoCamera"
{
    float4[] clippingPlanes = [] (
        doc = """Additional, arbitrarily oriented clipping planes.\r
                 A vector (a,b,c,d) encodes a clipping plane that cuts off\r
                 (x,y,z) with a * x + b * y + c * z + d * 1 < 0 where (x,y,z)\r
                 are the coordinates in the camera's space."""
    )
    float2 clippingRange = (1, 1000000) (
        doc = """Near and far clipping distances in centimeters (or, more\r
                 general, world units)."""
    )
    float exposure = 0
    float far_clip = 1e30
    float focalLength = 50 (
        doc = """Perspective focal length in millimeters (or, more general,\r
                 tenths of a world unit)."""
    )
    float focusDistance = 0 (
        doc = """Distance from the camera to the focus plane in centimeters (or\r
                 more general, world units)."""
    )
    float fStop = 0 (
        doc = "Lens aperture. Defaults to 0.0, which turns off focusing."
    )
    token handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    float horizontalAperture = 20.955 (
        doc = """Horizontal aperture in millimeters (or, more general, tenths\r
                 of a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float horizontalApertureOffset = 0 (
        doc = """Horizontal aperture offset in the same units as\r
                 horizontalAperture. Defaults to 0."""
    )
    vector3f[] look_at
    matrix4d[] matrix
    float motion_end = 1
    float motion_start = 0
    float near_clip = 0.0001
    vector3f[] position
    token projection = "perspective" (
        allowedTokens = ["perspective", "orthographic"]
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    token rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float rolling_shutter_duration = 0
    float2[] screen_window_max
    float2[] screen_window_min
    double shutter:close = 0 (
        doc = """Frame relative shutter close time, analogous comments from\r
                 shutter:open apply. A value greater or equal to shutter:open\r
                 should be authored, otherwise there is no exposure and a\r
                 renderer should produce a black image."""
    )
    double shutter:open = 0 (
        doc = """Frame relative shutter open time in UsdTimeCode units (negative\r
                 value indicates that the shutter opens before the current\r
                 frame time). Used for motion blur."""
    )
    float2[] shutter_curve
    float shutter_end = 0
    float shutter_start = 0
    token shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    uniform token stereoRole = "mono" (
        allowedTokens = ["mono", "left", "right"]
        doc = """If different from mono, the camera is intended to be the left\r
                 or right camera of a stereo setup."""
    )
    vector3f[] up
    float verticalAperture = 15.2908 (
        doc = """Vertical aperture in millimeters (or, more general, tenths of\r
                 a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float verticalApertureOffset = 0 (
        doc = """Vertical aperture offset in the same units as\r
                 verticalAperture. Defaults to 0."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldFisheyeCamera "ArnoldFisheyeCamera"
{
    float aperture_aspect_ratio = 1
    float aperture_blade_curvature = 0
    int aperture_blades = 0
    float aperture_rotation = 0
    float[] aperture_size
    bool autocrop = 0
    float4[] clippingPlanes = [] (
        doc = """Additional, arbitrarily oriented clipping planes.\r
                 A vector (a,b,c,d) encodes a clipping plane that cuts off\r
                 (x,y,z) with a * x + b * y + c * z + d * 1 < 0 where (x,y,z)\r
                 are the coordinates in the camera's space."""
    )
    float2 clippingRange = (1, 1000000) (
        doc = """Near and far clipping distances in centimeters (or, more\r
                 general, world units)."""
    )
    float exposure = 0
    float far_clip = 1e30
    float focalLength = 50 (
        doc = """Perspective focal length in millimeters (or, more general,\r
                 tenths of a world unit)."""
    )
    float[] focus_distance
    float focusDistance = 0 (
        doc = """Distance from the camera to the focus plane in centimeters (or\r
                 more general, world units)."""
    )
    float[] fov
    float fStop = 0 (
        doc = "Lens aperture. Defaults to 0.0, which turns off focusing."
    )
    token handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    float horizontalAperture = 20.955 (
        doc = """Horizontal aperture in millimeters (or, more general, tenths\r
                 of a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float horizontalApertureOffset = 0 (
        doc = """Horizontal aperture offset in the same units as\r
                 horizontalAperture. Defaults to 0."""
    )
    vector3f[] look_at
    matrix4d[] matrix
    float motion_end = 1
    float motion_start = 0
    float near_clip = 0.0001
    vector3f[] position
    token projection = "perspective" (
        allowedTokens = ["perspective", "orthographic"]
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    token rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float rolling_shutter_duration = 0
    float2[] screen_window_max
    float2[] screen_window_min
    double shutter:close = 0 (
        doc = """Frame relative shutter close time, analogous comments from\r
                 shutter:open apply. A value greater or equal to shutter:open\r
                 should be authored, otherwise there is no exposure and a\r
                 renderer should produce a black image."""
    )
    double shutter:open = 0 (
        doc = """Frame relative shutter open time in UsdTimeCode units (negative\r
                 value indicates that the shutter opens before the current\r
                 frame time). Used for motion blur."""
    )
    float2[] shutter_curve
    float shutter_end = 0
    float shutter_start = 0
    token shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    uniform token stereoRole = "mono" (
        allowedTokens = ["mono", "left", "right"]
        doc = """If different from mono, the camera is intended to be the left\r
                 or right camera of a stereo setup."""
    )
    vector3f[] up
    float verticalAperture = 15.2908 (
        doc = """Vertical aperture in millimeters (or, more general, tenths of\r
                 a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float verticalApertureOffset = 0 (
        doc = """Vertical aperture offset in the same units as\r
                 verticalAperture. Defaults to 0."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldCylCamera "ArnoldCylCamera"
{
    float4[] clippingPlanes = [] (
        doc = """Additional, arbitrarily oriented clipping planes.\r
                 A vector (a,b,c,d) encodes a clipping plane that cuts off\r
                 (x,y,z) with a * x + b * y + c * z + d * 1 < 0 where (x,y,z)\r
                 are the coordinates in the camera's space."""
    )
    float2 clippingRange = (1, 1000000) (
        doc = """Near and far clipping distances in centimeters (or, more\r
                 general, world units)."""
    )
    float exposure = 0
    float far_clip = 1e30
    float focalLength = 50 (
        doc = """Perspective focal length in millimeters (or, more general,\r
                 tenths of a world unit)."""
    )
    float focusDistance = 0 (
        doc = """Distance from the camera to the focus plane in centimeters (or\r
                 more general, world units)."""
    )
    float fStop = 0 (
        doc = "Lens aperture. Defaults to 0.0, which turns off focusing."
    )
    token handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    float[] horizontal_fov
    float horizontalAperture = 20.955 (
        doc = """Horizontal aperture in millimeters (or, more general, tenths\r
                 of a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float horizontalApertureOffset = 0 (
        doc = """Horizontal aperture offset in the same units as\r
                 horizontalAperture. Defaults to 0."""
    )
    vector3f[] look_at
    matrix4d[] matrix
    float motion_end = 1
    float motion_start = 0
    float near_clip = 0.0001
    vector3f[] position
    token projection = "perspective" (
        allowedTokens = ["perspective", "orthographic"]
    )
    bool projective = 1
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    token rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float rolling_shutter_duration = 0
    float2[] screen_window_max
    float2[] screen_window_min
    double shutter:close = 0 (
        doc = """Frame relative shutter close time, analogous comments from\r
                 shutter:open apply. A value greater or equal to shutter:open\r
                 should be authored, otherwise there is no exposure and a\r
                 renderer should produce a black image."""
    )
    double shutter:open = 0 (
        doc = """Frame relative shutter open time in UsdTimeCode units (negative\r
                 value indicates that the shutter opens before the current\r
                 frame time). Used for motion blur."""
    )
    float2[] shutter_curve
    float shutter_end = 0
    float shutter_start = 0
    token shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    uniform token stereoRole = "mono" (
        allowedTokens = ["mono", "left", "right"]
        doc = """If different from mono, the camera is intended to be the left\r
                 or right camera of a stereo setup."""
    )
    vector3f[] up
    float[] vertical_fov
    float verticalAperture = 15.2908 (
        doc = """Vertical aperture in millimeters (or, more general, tenths of\r
                 a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float verticalApertureOffset = 0 (
        doc = """Vertical aperture offset in the same units as\r
                 verticalAperture. Defaults to 0."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldSphericalCamera "ArnoldSphericalCamera"
{
    float4[] clippingPlanes = [] (
        doc = """Additional, arbitrarily oriented clipping planes.\r
                 A vector (a,b,c,d) encodes a clipping plane that cuts off\r
                 (x,y,z) with a * x + b * y + c * z + d * 1 < 0 where (x,y,z)\r
                 are the coordinates in the camera's space."""
    )
    float2 clippingRange = (1, 1000000) (
        doc = """Near and far clipping distances in centimeters (or, more\r
                 general, world units)."""
    )
    float exposure = 0
    float far_clip = 1e30
    float focalLength = 50 (
        doc = """Perspective focal length in millimeters (or, more general,\r
                 tenths of a world unit)."""
    )
    float focusDistance = 0 (
        doc = """Distance from the camera to the focus plane in centimeters (or\r
                 more general, world units)."""
    )
    float fStop = 0 (
        doc = "Lens aperture. Defaults to 0.0, which turns off focusing."
    )
    token handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    float horizontalAperture = 20.955 (
        doc = """Horizontal aperture in millimeters (or, more general, tenths\r
                 of a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float horizontalApertureOffset = 0 (
        doc = """Horizontal aperture offset in the same units as\r
                 horizontalAperture. Defaults to 0."""
    )
    vector3f[] look_at
    matrix4d[] matrix
    float motion_end = 1
    float motion_start = 0
    float near_clip = 0.0001
    vector3f[] position
    token projection = "perspective" (
        allowedTokens = ["perspective", "orthographic"]
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    token rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float rolling_shutter_duration = 0
    float2[] screen_window_max
    float2[] screen_window_min
    double shutter:close = 0 (
        doc = """Frame relative shutter close time, analogous comments from\r
                 shutter:open apply. A value greater or equal to shutter:open\r
                 should be authored, otherwise there is no exposure and a\r
                 renderer should produce a black image."""
    )
    double shutter:open = 0 (
        doc = """Frame relative shutter open time in UsdTimeCode units (negative\r
                 value indicates that the shutter opens before the current\r
                 frame time). Used for motion blur."""
    )
    float2[] shutter_curve
    float shutter_end = 0
    float shutter_start = 0
    token shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    uniform token stereoRole = "mono" (
        allowedTokens = ["mono", "left", "right"]
        doc = """If different from mono, the camera is intended to be the left\r
                 or right camera of a stereo setup."""
    )
    vector3f[] up
    float verticalAperture = 15.2908 (
        doc = """Vertical aperture in millimeters (or, more general, tenths of\r
                 a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float verticalApertureOffset = 0 (
        doc = """Vertical aperture offset in the same units as\r
                 verticalAperture. Defaults to 0."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldVrCamera "ArnoldVrCamera"
{
    float bottom_merge_angle = 90
    token bottom_merge_mode = "cosine" (
        allowedTokens = ["none", "cosine", "shader"]
    )
    float4[] clippingPlanes = [] (
        doc = """Additional, arbitrarily oriented clipping planes.\r
                 A vector (a,b,c,d) encodes a clipping plane that cuts off\r
                 (x,y,z) with a * x + b * y + c * z + d * 1 < 0 where (x,y,z)\r
                 are the coordinates in the camera's space."""
    )
    float2 clippingRange = (1, 1000000) (
        doc = """Near and far clipping distances in centimeters (or, more\r
                 general, world units)."""
    )
    float exposure = 0
    float eye_separation = 0.65
    float eye_to_neck = 0
    float far_clip = 1e30
    float focalLength = 50 (
        doc = """Perspective focal length in millimeters (or, more general,\r
                 tenths of a world unit)."""
    )
    float focusDistance = 0 (
        doc = """Distance from the camera to the focus plane in centimeters (or\r
                 more general, world units)."""
    )
    float fStop = 0 (
        doc = "Lens aperture. Defaults to 0.0, which turns off focusing."
    )
    token handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    float horizontalAperture = 20.955 (
        doc = """Horizontal aperture in millimeters (or, more general, tenths\r
                 of a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float horizontalApertureOffset = 0 (
        doc = """Horizontal aperture offset in the same units as\r
                 horizontalAperture. Defaults to 0."""
    )
    vector3f[] look_at
    matrix4d[] matrix
    float merge_shader = 0
    token mode = "side_by_side" (
        allowedTokens = ["side_by_side", "over_under", "left_eye", "right_eye"]
    )
    float motion_end = 1
    float motion_start = 0
    float near_clip = 0.0001
    vector3f[] position
    token projection = "latlong" (
        allowedTokens = ["latlong", "cubemap_6x1", "cubemap_3x2"]
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    token rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float rolling_shutter_duration = 0
    float2[] screen_window_max
    float2[] screen_window_min
    double shutter:close = 0 (
        doc = """Frame relative shutter close time, analogous comments from\r
                 shutter:open apply. A value greater or equal to shutter:open\r
                 should be authored, otherwise there is no exposure and a\r
                 renderer should produce a black image."""
    )
    double shutter:open = 0 (
        doc = """Frame relative shutter open time in UsdTimeCode units (negative\r
                 value indicates that the shutter opens before the current\r
                 frame time). Used for motion blur."""
    )
    float2[] shutter_curve
    float shutter_end = 0
    float shutter_start = 0
    token shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    uniform token stereoRole = "mono" (
        allowedTokens = ["mono", "left", "right"]
        doc = """If different from mono, the camera is intended to be the left\r
                 or right camera of a stereo setup."""
    )
    float top_merge_angle = 90
    token top_merge_mode = "cosine" (
        allowedTokens = ["none", "cosine", "shader"]
    )
    vector3f[] up
    float verticalAperture = 15.2908 (
        doc = """Vertical aperture in millimeters (or, more general, tenths of\r
                 a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float verticalApertureOffset = 0 (
        doc = """Vertical aperture offset in the same units as\r
                 verticalAperture. Defaults to 0."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldUvCamera "ArnoldUvCamera"
{
    float4[] clippingPlanes = [] (
        doc = """Additional, arbitrarily oriented clipping planes.\r
                 A vector (a,b,c,d) encodes a clipping plane that cuts off\r
                 (x,y,z) with a * x + b * y + c * z + d * 1 < 0 where (x,y,z)\r
                 are the coordinates in the camera's space."""
    )
    float2 clippingRange = (1, 1000000) (
        doc = """Near and far clipping distances in centimeters (or, more\r
                 general, world units)."""
    )
    float exposure = 0
    bool extend_edges = 1
    float far_clip = 1e30
    float focalLength = 50 (
        doc = """Perspective focal length in millimeters (or, more general,\r
                 tenths of a world unit)."""
    )
    float focusDistance = 0 (
        doc = """Distance from the camera to the focus plane in centimeters (or\r
                 more general, world units)."""
    )
    float fStop = 0 (
        doc = "Lens aperture. Defaults to 0.0, which turns off focusing."
    )
    int grid_size = 16
    token handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    float horizontalAperture = 20.955 (
        doc = """Horizontal aperture in millimeters (or, more general, tenths\r
                 of a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float horizontalApertureOffset = 0 (
        doc = """Horizontal aperture offset in the same units as\r
                 horizontalAperture. Defaults to 0."""
    )
    vector3f[] look_at
    matrix4d[] matrix
    float motion_end = 1
    float motion_start = 0
    float near_clip = 0.0001
    float offset = 0.1
    vector3f[] position
    token projection = "perspective" (
        allowedTokens = ["perspective", "orthographic"]
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    vector3f ray_direction = (0, 0, 0)
    vector3f ray_origin = (0, 0, 0)
    token rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float rolling_shutter_duration = 0
    float2[] screen_window_max
    float2[] screen_window_min
    double shutter:close = 0 (
        doc = """Frame relative shutter close time, analogous comments from\r
                 shutter:open apply. A value greater or equal to shutter:open\r
                 should be authored, otherwise there is no exposure and a\r
                 renderer should produce a black image."""
    )
    double shutter:open = 0 (
        doc = """Frame relative shutter open time in UsdTimeCode units (negative\r
                 value indicates that the shutter opens before the current\r
                 frame time). Used for motion blur."""
    )
    float2[] shutter_curve
    float shutter_end = 0
    float shutter_start = 0
    token shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    uniform token stereoRole = "mono" (
        allowedTokens = ["mono", "left", "right"]
        doc = """If different from mono, the camera is intended to be the left\r
                 or right camera of a stereo setup."""
    )
    float u_offset = 0
    float u_scale = 1
    vector3f[] up
    string uv_set = ""
    float v_offset = 0
    float v_scale = 1
    float verticalAperture = 15.2908 (
        doc = """Vertical aperture in millimeters (or, more general, tenths of\r
                 a world unit).\r
                 Defaults to the standard 35mm spherical projector aperture."""
    )
    float verticalApertureOffset = 0 (
        doc = """Vertical aperture offset in the same units as\r
                 verticalAperture. Defaults to 0."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldPointLight "ArnoldPointLight" (
    apiSchemas = ["CollectionAPI:lightLink", "CollectionAPI:shadowLink"]
)
{
    string aov = "default"
    float camera = 0
    bool cast_shadows = 1
    bool cast_volumetric_shadows = 1
    uniform bool collection:lightLink:includeRoot = 1
    uniform bool collection:shadowLink:includeRoot = 1
    color3f color = (1, 1, 1) (
        doc = "The color of emitted light, in energy-linear terms."
    )
    float colorTemperature = 6500 (
        displayName = "Color Temperature"
        doc = """Color temperature, in degrees Kelvin, representing the\r
        white point.  The default is a common white point, D65.  Lower\r
        values are warmer and higher values are cooler.  The valid range\r
        is from 1000 to 10000. Only takes effect when\r
        enableColorTemperature is set to true.  When active, the\r
        computed result multiplies against the color attribute.\r
        See UsdLuxBlackbodyTemperatureAsRgb()."""
    )
    float diffuse = 1 (
        displayName = "Diffuse Multiplier"
        doc = """A multiplier for the effect of this light on the diffuse\r
        response of materials.  This is a non-physical control."""
    )
    bool enableColorTemperature = 0 (
        displayName = "Enable Color Temperature"
        doc = "Enables using colorTemperature."
    )
    float exposure = 0 (
        doc = """Scales the power of the light exponentially as a power\r
        of 2 (similar to an F-stop control over exposure).  The result\r
        is multiplied against the intensity."""
    )
    rel filters (
        doc = "Relationship to the light filters that apply to this light."
    )
    float indirect = 1
    float intensity = 1 (
        doc = "Scales the power of the light linearly."
    )
    matrix4d[] matrix
    int max_bounces = 999
    float motion_end = 1
    float motion_start = 0
    bool normalize = 1 (
        displayName = "Normalize Power"
        doc = """Normalizes power by the surface area of the light.\r
        This makes it easier to independently adjust the power and shape\r
        of the light, by causing the power to not vary with the area or\r
        angular size of the light."""
    )
    vector3f[] position
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float radius = 0
    int samples = 1
    color3f shadow_color = (0, 0, 0)
    float shadow_density = 1
    float specular = 1 (
        displayName = "Specular Multiplier"
        doc = """A multiplier for the effect of this light on the specular\r
        response of materials.  This is a non-physical control."""
    )
    float sss = 1
    float transmission = 0
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float volume = 1
    int volume_samples = 2
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldDistantLight "ArnoldDistantLight" (
    apiSchemas = ["CollectionAPI:lightLink", "CollectionAPI:shadowLink"]
)
{
    float angle = 0
    string aov = "default"
    bool cast_shadows = 1
    bool cast_volumetric_shadows = 1
    uniform bool collection:lightLink:includeRoot = 1
    uniform bool collection:shadowLink:includeRoot = 1
    color3f color = (1, 1, 1) (
        doc = "The color of emitted light, in energy-linear terms."
    )
    float colorTemperature = 6500 (
        displayName = "Color Temperature"
        doc = """Color temperature, in degrees Kelvin, representing the\r
        white point.  The default is a common white point, D65.  Lower\r
        values are warmer and higher values are cooler.  The valid range\r
        is from 1000 to 10000. Only takes effect when\r
        enableColorTemperature is set to true.  When active, the\r
        computed result multiplies against the color attribute.\r
        See UsdLuxBlackbodyTemperatureAsRgb()."""
    )
    float diffuse = 1 (
        displayName = "Diffuse Multiplier"
        doc = """A multiplier for the effect of this light on the diffuse\r
        response of materials.  This is a non-physical control."""
    )
    vector3f[] direction
    bool enableColorTemperature = 0 (
        displayName = "Enable Color Temperature"
        doc = "Enables using colorTemperature."
    )
    float exposure = 0 (
        doc = """Scales the power of the light exponentially as a power\r
        of 2 (similar to an F-stop control over exposure).  The result\r
        is multiplied against the intensity."""
    )
    rel filters (
        doc = "Relationship to the light filters that apply to this light."
    )
    float indirect = 1
    float intensity = 1 (
        doc = "Scales the power of the light linearly."
    )
    matrix4d[] matrix
    int max_bounces = 999
    float motion_end = 1
    float motion_start = 0
    bool normalize = 1 (
        displayName = "Normalize Power"
        doc = """Normalizes power by the surface area of the light.\r
        This makes it easier to independently adjust the power and shape\r
        of the light, by causing the power to not vary with the area or\r
        angular size of the light."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    int samples = 1
    color3f shadow_color = (0, 0, 0)
    float shadow_density = 1
    float specular = 1 (
        displayName = "Specular Multiplier"
        doc = """A multiplier for the effect of this light on the specular\r
        response of materials.  This is a non-physical control."""
    )
    float sss = 1
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float volume = 1
    int volume_samples = 2
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class "ArnoldDistantLightAPI"
{
    string primvars:arnold:aov = "default"
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    vector3f[] primvars:arnold:direction
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class ArnoldQuadLight "ArnoldQuadLight" (
    apiSchemas = ["CollectionAPI:lightLink", "CollectionAPI:shadowLink"]
)
{
    string aov = "default"
    float camera = 0
    bool cast_shadows = 1
    bool cast_volumetric_shadows = 1
    uniform bool collection:lightLink:includeRoot = 1
    uniform bool collection:shadowLink:includeRoot = 1
    color3f color = (1, 1, 1) (
        doc = "The color of emitted light, in energy-linear terms."
    )
    float colorTemperature = 6500 (
        displayName = "Color Temperature"
        doc = """Color temperature, in degrees Kelvin, representing the\r
        white point.  The default is a common white point, D65.  Lower\r
        values are warmer and higher values are cooler.  The valid range\r
        is from 1000 to 10000. Only takes effect when\r
        enableColorTemperature is set to true.  When active, the\r
        computed result multiplies against the color attribute.\r
        See UsdLuxBlackbodyTemperatureAsRgb()."""
    )
    float diffuse = 1 (
        displayName = "Diffuse Multiplier"
        doc = """A multiplier for the effect of this light on the diffuse\r
        response of materials.  This is a non-physical control."""
    )
    bool enableColorTemperature = 0 (
        displayName = "Enable Color Temperature"
        doc = "Enables using colorTemperature."
    )
    float exposure = 0 (
        doc = """Scales the power of the light exponentially as a power\r
        of 2 (similar to an F-stop control over exposure).  The result\r
        is multiplied against the intensity."""
    )
    rel filters (
        doc = "Relationship to the light filters that apply to this light."
    )
    float indirect = 1
    float intensity = 1 (
        doc = "Scales the power of the light linearly."
    )
    matrix4d[] matrix
    int max_bounces = 999
    float motion_end = 1
    float motion_start = 0
    bool normalize = 1 (
        displayName = "Normalize Power"
        doc = """Normalizes power by the surface area of the light.\r
        This makes it easier to independently adjust the power and shape\r
        of the light, by causing the power to not vary with the area or\r
        angular size of the light."""
    )
    bool portal = 0
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    int resolution = 512
    float roundness = 0
    int samples = 1
    color3f shadow_color = (0, 0, 0)
    float shadow_density = 1
    float soft_edge = 0
    float specular = 1 (
        displayName = "Specular Multiplier"
        doc = """A multiplier for the effect of this light on the specular\r
        response of materials.  This is a non-physical control."""
    )
    float spread = 1
    float sss = 1
    float transmission = 0
    vector3f[] vertices
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float volume = 1
    int volume_samples = 2
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class "ArnoldQuadLightAPI"
{
    string primvars:arnold:aov = "default"
    float primvars:arnold:camera = 0
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:portal = 0
    int primvars:arnold:resolution = 512
    float primvars:arnold:roundness = 0
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:soft_edge = 0
    float primvars:arnold:spread = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:transmission = 0
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class ArnoldSpotLight "ArnoldSpotLight" (
    apiSchemas = ["CollectionAPI:lightLink", "CollectionAPI:shadowLink"]
)
{
    string aov = "default"
    float aspect_ratio = 1
    bool cast_shadows = 1
    bool cast_volumetric_shadows = 1
    uniform bool collection:lightLink:includeRoot = 1
    uniform bool collection:shadowLink:includeRoot = 1
    color3f color = (1, 1, 1) (
        doc = "The color of emitted light, in energy-linear terms."
    )
    float colorTemperature = 6500 (
        displayName = "Color Temperature"
        doc = """Color temperature, in degrees Kelvin, representing the\r
        white point.  The default is a common white point, D65.  Lower\r
        values are warmer and higher values are cooler.  The valid range\r
        is from 1000 to 10000. Only takes effect when\r
        enableColorTemperature is set to true.  When active, the\r
        computed result multiplies against the color attribute.\r
        See UsdLuxBlackbodyTemperatureAsRgb()."""
    )
    float cone_angle = 65
    float cosine_power = 0
    float diffuse = 1 (
        displayName = "Diffuse Multiplier"
        doc = """A multiplier for the effect of this light on the diffuse\r
        response of materials.  This is a non-physical control."""
    )
    bool enableColorTemperature = 0 (
        displayName = "Enable Color Temperature"
        doc = "Enables using colorTemperature."
    )
    float exposure = 0 (
        doc = """Scales the power of the light exponentially as a power\r
        of 2 (similar to an F-stop control over exposure).  The result\r
        is multiplied against the intensity."""
    )
    rel filters (
        doc = "Relationship to the light filters that apply to this light."
    )
    float indirect = 1
    float intensity = 1 (
        doc = "Scales the power of the light linearly."
    )
    float lens_radius = 0
    vector3f[] look_at
    matrix4d[] matrix
    int max_bounces = 999
    float motion_end = 1
    float motion_start = 0
    bool normalize = 1 (
        displayName = "Normalize Power"
        doc = """Normalizes power by the surface area of the light.\r
        This makes it easier to independently adjust the power and shape\r
        of the light, by causing the power to not vary with the area or\r
        angular size of the light."""
    )
    float penumbra_angle = 0
    vector3f[] position
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float radius = 0
    float roundness = 1
    int samples = 1
    color3f shadow_color = (0, 0, 0)
    float shadow_density = 1
    float specular = 1 (
        displayName = "Specular Multiplier"
        doc = """A multiplier for the effect of this light on the specular\r
        response of materials.  This is a non-physical control."""
    )
    float sss = 1
    vector3f[] up
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float volume = 1
    int volume_samples = 2
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldSkydomeLight "ArnoldSkydomeLight" (
    apiSchemas = ["CollectionAPI:lightLink", "CollectionAPI:shadowLink"]
)
{
    string aov = "default"
    bool aov_indirect = 0
    float camera = 1
    bool cast_shadows = 1
    bool cast_volumetric_shadows = 1
    uniform bool collection:lightLink:includeRoot = 1
    uniform bool collection:shadowLink:includeRoot = 1
    color3f color = (1, 1, 1) (
        doc = "The color of emitted light, in energy-linear terms."
    )
    float colorTemperature = 6500 (
        displayName = "Color Temperature"
        doc = """Color temperature, in degrees Kelvin, representing the\r
        white point.  The default is a common white point, D65.  Lower\r
        values are warmer and higher values are cooler.  The valid range\r
        is from 1000 to 10000. Only takes effect when\r
        enableColorTemperature is set to true.  When active, the\r
        computed result multiplies against the color attribute.\r
        See UsdLuxBlackbodyTemperatureAsRgb()."""
    )
    float diffuse = 1 (
        displayName = "Diffuse Multiplier"
        doc = """A multiplier for the effect of this light on the diffuse\r
        response of materials.  This is a non-physical control."""
    )
    bool enableColorTemperature = 0 (
        displayName = "Enable Color Temperature"
        doc = "Enables using colorTemperature."
    )
    float exposure = 0 (
        doc = """Scales the power of the light exponentially as a power\r
        of 2 (similar to an F-stop control over exposure).  The result\r
        is multiplied against the intensity."""
    )
    rel filters (
        doc = "Relationship to the light filters that apply to this light."
    )
    token format = "angular" (
        allowedTokens = ["mirrored_ball", "angular", "latlong"]
    )
    float indirect = 1
    float intensity = 1 (
        doc = "Scales the power of the light linearly."
    )
    matrix4d[] matrix
    int max_bounces = 999
    float motion_end = 1
    float motion_start = 0
    bool normalize = 1 (
        displayName = "Normalize Power"
        doc = """Normalizes power by the surface area of the light.\r
        This makes it easier to independently adjust the power and shape\r
        of the light, by causing the power to not vary with the area or\r
        angular size of the light."""
    )
    token portal_mode = "interior_only" (
        allowedTokens = ["off", "interior_only", "interior_exterior"]
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    int resolution = 1000
    int samples = 1
    color3f shadow_color = (0, 0, 0)
    float shadow_density = 1
    float specular = 1 (
        displayName = "Specular Multiplier"
        doc = """A multiplier for the effect of this light on the specular\r
        response of materials.  This is a non-physical control."""
    )
    float sss = 1
    float transmission = 1
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float volume = 1
    int volume_samples = 2
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class "ArnoldSkydomeLightAPI"
{
    string primvars:arnold:aov = "default"
    bool primvars:arnold:aov_indirect = 0
    float primvars:arnold:camera = 1
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    token primvars:arnold:portal_mode = "interior_only" (
        allowedTokens = ["off", "interior_only", "interior_exterior"]
    )
    int primvars:arnold:resolution = 1000
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:transmission = 1
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class ArnoldCylinderLight "ArnoldCylinderLight" (
    apiSchemas = ["CollectionAPI:lightLink", "CollectionAPI:shadowLink"]
)
{
    string aov = "default"
    vector3f[] bottom
    float camera = 0
    bool cast_shadows = 1
    bool cast_volumetric_shadows = 1
    uniform bool collection:lightLink:includeRoot = 1
    uniform bool collection:shadowLink:includeRoot = 1
    color3f color = (1, 1, 1) (
        doc = "The color of emitted light, in energy-linear terms."
    )
    float colorTemperature = 6500 (
        displayName = "Color Temperature"
        doc = """Color temperature, in degrees Kelvin, representing the\r
        white point.  The default is a common white point, D65.  Lower\r
        values are warmer and higher values are cooler.  The valid range\r
        is from 1000 to 10000. Only takes effect when\r
        enableColorTemperature is set to true.  When active, the\r
        computed result multiplies against the color attribute.\r
        See UsdLuxBlackbodyTemperatureAsRgb()."""
    )
    float diffuse = 1 (
        displayName = "Diffuse Multiplier"
        doc = """A multiplier for the effect of this light on the diffuse\r
        response of materials.  This is a non-physical control."""
    )
    bool enableColorTemperature = 0 (
        displayName = "Enable Color Temperature"
        doc = "Enables using colorTemperature."
    )
    float exposure = 0 (
        doc = """Scales the power of the light exponentially as a power\r
        of 2 (similar to an F-stop control over exposure).  The result\r
        is multiplied against the intensity."""
    )
    rel filters (
        doc = "Relationship to the light filters that apply to this light."
    )
    float indirect = 1
    float intensity = 1 (
        doc = "Scales the power of the light linearly."
    )
    matrix4d[] matrix
    int max_bounces = 999
    float motion_end = 1
    float motion_start = 0
    bool normalize = 1 (
        displayName = "Normalize Power"
        doc = """Normalizes power by the surface area of the light.\r
        This makes it easier to independently adjust the power and shape\r
        of the light, by causing the power to not vary with the area or\r
        angular size of the light."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float radius = 1
    int samples = 1
    color3f shadow_color = (0, 0, 0)
    float shadow_density = 1
    float specular = 1 (
        displayName = "Specular Multiplier"
        doc = """A multiplier for the effect of this light on the specular\r
        response of materials.  This is a non-physical control."""
    )
    float sss = 1
    vector3f[] top
    float transmission = 0
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float volume = 1
    int volume_samples = 2
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldDiskLight "ArnoldDiskLight" (
    apiSchemas = ["CollectionAPI:lightLink", "CollectionAPI:shadowLink"]
)
{
    string aov = "default"
    float camera = 0
    bool cast_shadows = 1
    bool cast_volumetric_shadows = 1
    uniform bool collection:lightLink:includeRoot = 1
    uniform bool collection:shadowLink:includeRoot = 1
    color3f color = (1, 1, 1) (
        doc = "The color of emitted light, in energy-linear terms."
    )
    float colorTemperature = 6500 (
        displayName = "Color Temperature"
        doc = """Color temperature, in degrees Kelvin, representing the\r
        white point.  The default is a common white point, D65.  Lower\r
        values are warmer and higher values are cooler.  The valid range\r
        is from 1000 to 10000. Only takes effect when\r
        enableColorTemperature is set to true.  When active, the\r
        computed result multiplies against the color attribute.\r
        See UsdLuxBlackbodyTemperatureAsRgb()."""
    )
    float diffuse = 1 (
        displayName = "Diffuse Multiplier"
        doc = """A multiplier for the effect of this light on the diffuse\r
        response of materials.  This is a non-physical control."""
    )
    vector3f[] direction
    bool enableColorTemperature = 0 (
        displayName = "Enable Color Temperature"
        doc = "Enables using colorTemperature."
    )
    float exposure = 0 (
        doc = """Scales the power of the light exponentially as a power\r
        of 2 (similar to an F-stop control over exposure).  The result\r
        is multiplied against the intensity."""
    )
    rel filters (
        doc = "Relationship to the light filters that apply to this light."
    )
    float indirect = 1
    float intensity = 1 (
        doc = "Scales the power of the light linearly."
    )
    matrix4d[] matrix
    int max_bounces = 999
    float motion_end = 1
    float motion_start = 0
    bool normalize = 1 (
        displayName = "Normalize Power"
        doc = """Normalizes power by the surface area of the light.\r
        This makes it easier to independently adjust the power and shape\r
        of the light, by causing the power to not vary with the area or\r
        angular size of the light."""
    )
    vector3f[] position
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float radius = 0.5
    int samples = 1
    color3f shadow_color = (0, 0, 0)
    float shadow_density = 1
    float specular = 1 (
        displayName = "Specular Multiplier"
        doc = """A multiplier for the effect of this light on the specular\r
        response of materials.  This is a non-physical control."""
    )
    float spread = 1
    float sss = 1
    float transmission = 0
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float volume = 1
    int volume_samples = 2
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class "ArnoldDiskLightAPI"
{
    string primvars:arnold:aov = "default"
    float primvars:arnold:camera = 0
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    vector3f[] primvars:arnold:direction
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    vector3f[] primvars:arnold:position
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:spread = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:transmission = 0
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class ArnoldMeshLight "ArnoldMeshLight" (
    apiSchemas = ["CollectionAPI:lightLink", "CollectionAPI:shadowLink"]
)
{
    string aov = "default"
    bool cast_shadows = 1
    bool cast_volumetric_shadows = 1
    uniform bool collection:lightLink:includeRoot = 1
    uniform bool collection:shadowLink:includeRoot = 1
    color3f color = (1, 1, 1) (
        doc = "The color of emitted light, in energy-linear terms."
    )
    float colorTemperature = 6500 (
        displayName = "Color Temperature"
        doc = """Color temperature, in degrees Kelvin, representing the\r
        white point.  The default is a common white point, D65.  Lower\r
        values are warmer and higher values are cooler.  The valid range\r
        is from 1000 to 10000. Only takes effect when\r
        enableColorTemperature is set to true.  When active, the\r
        computed result multiplies against the color attribute.\r
        See UsdLuxBlackbodyTemperatureAsRgb()."""
    )
    float diffuse = 1 (
        displayName = "Diffuse Multiplier"
        doc = """A multiplier for the effect of this light on the diffuse\r
        response of materials.  This is a non-physical control."""
    )
    bool enableColorTemperature = 0 (
        displayName = "Enable Color Temperature"
        doc = "Enables using colorTemperature."
    )
    float exposure = 0 (
        doc = """Scales the power of the light exponentially as a power\r
        of 2 (similar to an F-stop control over exposure).  The result\r
        is multiplied against the intensity."""
    )
    rel filters (
        doc = "Relationship to the light filters that apply to this light."
    )
    float indirect = 1
    float intensity = 1 (
        doc = "Scales the power of the light linearly."
    )
    matrix4d[] matrix
    int max_bounces = 999
    float motion_end = 1
    float motion_start = 0
    bool normalize = 1 (
        displayName = "Normalize Power"
        doc = """Normalizes power by the surface area of the light.\r
        This makes it easier to independently adjust the power and shape\r
        of the light, by causing the power to not vary with the area or\r
        angular size of the light."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    int samples = 1
    color3f shadow_color = (0, 0, 0)
    float shadow_density = 1
    float specular = 1 (
        displayName = "Specular Multiplier"
        doc = """A multiplier for the effect of this light on the specular\r
        response of materials.  This is a non-physical control."""
    )
    float sss = 1
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float volume = 1
    int volume_samples = 2
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class "ArnoldMeshLightAPI"
{
    string primvars:arnold:aov = "default"
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class ArnoldPhotometricLight "ArnoldPhotometricLight" (
    apiSchemas = ["CollectionAPI:lightLink", "CollectionAPI:shadowLink"]
)
{
    string aov = "default"
    bool cast_shadows = 1
    bool cast_volumetric_shadows = 1
    uniform bool collection:lightLink:includeRoot = 1
    uniform bool collection:shadowLink:includeRoot = 1
    color3f color = (1, 1, 1) (
        doc = "The color of emitted light, in energy-linear terms."
    )
    float colorTemperature = 6500 (
        displayName = "Color Temperature"
        doc = """Color temperature, in degrees Kelvin, representing the\r
        white point.  The default is a common white point, D65.  Lower\r
        values are warmer and higher values are cooler.  The valid range\r
        is from 1000 to 10000. Only takes effect when\r
        enableColorTemperature is set to true.  When active, the\r
        computed result multiplies against the color attribute.\r
        See UsdLuxBlackbodyTemperatureAsRgb()."""
    )
    float diffuse = 1 (
        displayName = "Diffuse Multiplier"
        doc = """A multiplier for the effect of this light on the diffuse\r
        response of materials.  This is a non-physical control."""
    )
    bool enableColorTemperature = 0 (
        displayName = "Enable Color Temperature"
        doc = "Enables using colorTemperature."
    )
    float exposure = 0 (
        doc = """Scales the power of the light exponentially as a power\r
        of 2 (similar to an F-stop control over exposure).  The result\r
        is multiplied against the intensity."""
    )
    string filename = ""
    rel filters (
        doc = "Relationship to the light filters that apply to this light."
    )
    float indirect = 1
    float intensity = 1 (
        doc = "Scales the power of the light linearly."
    )
    matrix4d[] matrix
    int max_bounces = 999
    float motion_end = 1
    float motion_start = 0
    bool normalize = 1 (
        displayName = "Normalize Power"
        doc = """Normalizes power by the surface area of the light.\r
        This makes it easier to independently adjust the power and shape\r
        of the light, by causing the power to not vary with the area or\r
        angular size of the light."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float radius = 0
    int samples = 1
    color3f shadow_color = (0, 0, 0)
    float shadow_density = 1
    float specular = 1 (
        displayName = "Specular Multiplier"
        doc = """A multiplier for the effect of this light on the specular\r
        response of materials.  This is a non-physical control."""
    )
    float sss = 1
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float volume = 1
    int volume_samples = 2
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldDriverJpeg "ArnoldDriverJpeg"
{
    string color_space = "auto"
    bool dither = 1
    string filename = "output.jpg"
    bool output_padded = 0
    int quality = 100
}

class ArnoldDriverNoOp "ArnoldDriverNoOp"
{
}

class ArnoldDriverPng "ArnoldDriverPng"
{
    string color_space = "auto"
    bool dither = 1
    string filename = "output.png"
    token format = "int8" (
        allowedTokens = ["int8", "int16"]
    )
    bool output_padded = 0
}

class ArnoldDriverTiff "ArnoldDriverTiff"
{
    bool append = 0
    string color_space = "auto"
    token compression = "lzw" (
        allowedTokens = ["none", "lzw", "ccittrle", "zip", "packbits"]
    )
    bool dither = 1
    string filename = "output.tif"
    token format = "int8" (
        allowedTokens = ["int8", "int16", "float32"]
    )
    bool output_padded = 0
    bool skip_alpha = 0
    bool tiled = 0
    bool unpremult_alpha = 0
}

class ArnoldDriverDeepexr "ArnoldDriverDeepexr"
{
    bool alpha_half_precision = 0
    float alpha_tolerance = 0.01
    bool append = 0
    string[] custom_attributes
    bool depth_half_precision = 0
    float depth_tolerance = 0.01
    string filename = "deep.exr"
    bool[] layer_enable_filtering
    bool[] layer_half_precision
    float[] layer_tolerance
    bool subpixel_merge = 1
    bool tiled = 0
    bool use_RGB_opacity = 0
}

class ArnoldDriverExr "ArnoldDriverExr"
{
    bool append = 0
    bool autocrop = 0
    string color_space = "auto"
    token compression = "zip" (
        allowedTokens = ["none", "rle", "zips", "zip", "piz", "pxr24", "b44", "b44a", "dwaa", "dwab"]
    )
    string[] custom_attributes
    string filename = "output.exr"
    bool half_precision = 0
    bool preserve_layer_name = 0
    bool tiled = 1
}

class ArnoldBoxFilter "ArnoldBoxFilter"
{
}

class ArnoldTriangleFilter "ArnoldTriangleFilter"
{
    float width = 2
}

class ArnoldCatromFilter "ArnoldCatromFilter"
{
}

class ArnoldMitnetFilter "ArnoldMitnetFilter"
{
}

class ArnoldGaussianFilter "ArnoldGaussianFilter"
{
    float width = 2
}

class ArnoldSincFilter "ArnoldSincFilter"
{
    float width = 6
}

class ArnoldBlackmanHarrisFilter "ArnoldBlackmanHarrisFilter"
{
    float width = 3
}

class ArnoldClosestFilter "ArnoldClosestFilter"
{
}

class ArnoldFarthestFilter "ArnoldFarthestFilter"
{
    token domain = "first_hit" (
        allowedTokens = ["first_hit", "all_hits"]
    )
}

class ArnoldVarianceFilter "ArnoldVarianceFilter"
{
    token filter_weights = "box" (
        allowedTokens = ["blackman_harris", "box", "catrom", "gaussian", "mitnet", "sinc", "triangle"]
    )
    bool scalar_mode = 0
    float width = 2
}

class ArnoldHeatmapFilter "ArnoldHeatmapFilter"
{
    float maximum = 1
    float minimum = 0
}

class ArnoldContourFilter "ArnoldContourFilter"
{
    float width = 1
}

class ArnoldDiffFilter "ArnoldDiffFilter"
{
    token filter_weights = "box" (
        allowedTokens = ["blackman_harris", "box", "catrom", "gaussian", "mitnet", "sinc", "triangle"]
    )
    float width = 2
}

class ArnoldDenoiseOptixFilter "ArnoldDenoiseOptixFilter"
{
    float blend = 0
}

class ArnoldSphere "ArnoldSphere"
{
    vector3f[] center
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    float motion_end = 1
    float motion_start = 0
    bool opaque = 1
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float[] radius
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar sidedness = 255
    float step_size = 0
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float volume_padding = 0
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class "ArnoldSphereAPI"
{
    vector3f[] primvars:arnold:center
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    uchar primvars:arnold:sidedness = 255
    float primvars:arnold:step_size = 0
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
    float primvars:arnold:volume_padding = 0
}

class ArnoldCylinder "ArnoldCylinder"
{
    float bevel_angle = 0.5
    float bevel_width = 0
    vector3f bottom = (0, 0, -0.5)
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    float motion_end = 1
    float motion_start = 0
    bool opaque = 1
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float radius = 0.5
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar sidedness = 255
    vector3f top = (0, 0, 0.5)
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class "ArnoldCylinderAPI"
{
    float primvars:arnold:bevel_angle = 0.5
    float primvars:arnold:bevel_width = 0
    vector3f primvars:arnold:bottom = (0, 0, -0.5)
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    uchar primvars:arnold:sidedness = 255
    vector3f primvars:arnold:top = (0, 0, 0.5)
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
}

class ArnoldCone "ArnoldCone"
{
    vector3f bottom = (0, 0, -0.5)
    float bottom_radius = 0.5
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    float motion_end = 1
    float motion_start = 0
    bool opaque = 1
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar sidedness = 255
    vector3f top = (0, 0, 0.5)
    float top_radius = 0
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class "ArnoldConeAPI"
{
    vector3f primvars:arnold:bottom = (0, 0, -0.5)
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    uchar primvars:arnold:sidedness = 255
    vector3f primvars:arnold:top = (0, 0, 0.5)
    float primvars:arnold:top_radius = 0
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
}

class ArnoldDisk "ArnoldDisk"
{
    float bevel_angle = 0.5
    float bevel_width = 0
    vector3f center = (0, 0, 0)
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    float hole = 0
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    float motion_end = 1
    float motion_start = 0
    vector3f normal = (0, 0, 1)
    bool opaque = 1
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float radius = 0.5
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar sidedness = 255
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldPlane "ArnoldPlane"
{
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    float motion_end = 1
    float motion_start = 0
    vector3f normal = (0, 0, 1)
    bool opaque = 1
    vector3f point = (0, 0, 0)
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar sidedness = 255
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldPolymesh "ArnoldPolymesh"
{
    uchar autobump_visibility = 1
    uint[] crease_idxs
    float[] crease_sharpness
    bool disp_autobump = 0
    float disp_height = 1
    float disp_padding = 0
    float disp_zero_value = 0
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    float motion_end = 1
    float motion_start = 0
    uint[] nidxs
    vector3f[] nlist
    uint[] nsides
    bool opaque = 1
    uint[] polygon_holes
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar[] shidxs
    uchar sidedness = 255
    bool smoothing = 0
    float step_size = 0
    float subdiv_adaptive_error = 0
    token subdiv_adaptive_metric = "metric_auto" (
        allowedTokens = ["metric_auto", "edge_length", "flatness"]
    )
    token subdiv_adaptive_space = "raster" (
        allowedTokens = ["raster", "object"]
    )
    bool subdiv_frustum_ignore = 0
    uchar subdiv_iterations = 1
    bool subdiv_smooth_derivs = 0
    token subdiv_type = "none" (
        allowedTokens = ["none", "catclark", "linear"]
    )
    token subdiv_uv_smoothing = "pin_corners" (
        allowedTokens = ["pin_corners", "pin_borders", "linear", "smooth"]
    )
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uint[] uvidxs
    float2[] uvlist
    uint[] vidxs
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    vector3f[] vlist
    float volume_padding = 0
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class "ArnoldPolymeshAPI"
{
    uchar primvars:arnold:autobump_visibility = 1
    uint[] primvars:arnold:crease_idxs
    float[] primvars:arnold:crease_sharpness
    bool primvars:arnold:disp_autobump = 0
    float primvars:arnold:disp_height = 1
    float primvars:arnold:disp_padding = 0
    float primvars:arnold:disp_zero_value = 0
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    vector3f[] primvars:arnold:nlist
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    uchar[] primvars:arnold:shidxs
    uchar primvars:arnold:sidedness = 255
    bool primvars:arnold:smoothing = 0
    float primvars:arnold:step_size = 0
    float primvars:arnold:subdiv_adaptive_error = 0
    token primvars:arnold:subdiv_adaptive_metric = "metric_auto" (
        allowedTokens = ["metric_auto", "edge_length", "flatness"]
    )
    token primvars:arnold:subdiv_adaptive_space = "raster" (
        allowedTokens = ["raster", "object"]
    )
    bool primvars:arnold:subdiv_frustum_ignore = 0
    uchar primvars:arnold:subdiv_iterations = 1
    bool primvars:arnold:subdiv_smooth_derivs = 0
    token primvars:arnold:subdiv_type = "none" (
        allowedTokens = ["none", "catclark", "linear"]
    )
    token primvars:arnold:subdiv_uv_smoothing = "pin_corners" (
        allowedTokens = ["pin_corners", "pin_borders", "linear", "smooth"]
    )
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uint[] primvars:arnold:uvidxs
    float2[] primvars:arnold:uvlist
    uchar primvars:arnold:visibility = 255
    vector3f[] primvars:arnold:vlist
    float primvars:arnold:volume_padding = 0
}

class ArnoldNurbs "ArnoldNurbs"
{
    uchar autobump_visibility = 1
    float[] cvs
    int degree_u = 3
    int degree_v = 3
    bool disp_autobump = 0
    float disp_height = 0
    float disp_padding = 0
    float disp_zero_value = 0
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    uint id = 0
    bool invert_normals = 0
    float[] knots_u
    float[] knots_v
    matrix4d[] matrix
    bool matte = 0
    float motion_end = 1
    float motion_start = 0
    bool opaque = 1
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar sidedness = 255
    bool smoothing = 1
    float step_size = 0
    int tesselate_u = 5
    int tesselate_v = 5
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float volume_padding = 0
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldBox "ArnoldBox"
{
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    vector3f max = (0.5, 0.5, 0.5)
    vector3f min = (-0.5, -0.5, -0.5)
    float motion_end = 1
    float motion_start = 0
    bool opaque = 1
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar sidedness = 255
    float step_size = 0
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float volume_padding = 0
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class "ArnoldBoxAPI"
{
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    uchar primvars:arnold:sidedness = 255
    float primvars:arnold:step_size = 0
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
    float primvars:arnold:volume_padding = 0
}

class ArnoldCurves "ArnoldCurves"
{
    token basis = "bezier" (
        allowedTokens = ["bezier", "b-spline", "catmull-rom", "linear"]
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    float min_pixel_width = 0
    token mode = "ribbon" (
        allowedTokens = ["ribbon", "thick", "oriented"]
    )
    float motion_end = 1
    float motion_start = 0
    uint[] num_points
    bool opaque = 1
    vector3f[] orientations
    vector3f[] points
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float[] radius
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar[] shidxs
    uchar sidedness = 255
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    float2[] uvs
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class "ArnoldCurvesAPI"
{
    token primvars:arnold:basis = "bezier" (
        allowedTokens = ["bezier", "b-spline", "catmull-rom", "linear"]
    )
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    bool primvars:arnold:matte = 0
    float primvars:arnold:min_pixel_width = 0
    token primvars:arnold:mode = "ribbon" (
        allowedTokens = ["ribbon", "thick", "oriented"]
    )
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    vector3f[] primvars:arnold:orientations
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    uchar[] primvars:arnold:shidxs
    uchar primvars:arnold:sidedness = 255
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    float2[] primvars:arnold:uvs
    uchar primvars:arnold:visibility = 255
}

class ArnoldPoints "ArnoldPoints"
{
    float[] aspect
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    float min_pixel_width = 0
    token mode = "disk" (
        allowedTokens = ["disk", "sphere", "quad"]
    )
    float motion_end = 1
    float motion_start = 0
    bool opaque = 1
    vector3f[] points
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float[] radius
    float ray_bias = 0.000001
    bool receive_shadows = 1
    float[] rotation
    bool self_shadows = 1
    uchar sidedness = 255
    float step_size = 0
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float volume_padding = 0
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class "ArnoldPointsAPI"
{
    float[] primvars:arnold:aspect
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    bool primvars:arnold:matte = 0
    float primvars:arnold:min_pixel_width = 0
    token primvars:arnold:mode = "disk" (
        allowedTokens = ["disk", "sphere", "quad"]
    )
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    float[] primvars:arnold:rotation
    bool primvars:arnold:self_shadows = 1
    uchar primvars:arnold:sidedness = 255
    float primvars:arnold:step_size = 0
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
    float primvars:arnold:volume_padding = 0
}

class ArnoldImplicit "ArnoldImplicit"
{
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    string field_channel = "field"
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    vector3f max = (0, 0, 0)
    vector3f min = (0, 0, 0)
    float motion_end = 1
    float motion_start = 0
    bool opaque = 1
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float ray_bias = 0.000001
    bool receive_shadows = 1
    uint samples = 10
    bool self_shadows = 1
    uchar sidedness = 255
    token solver = "uniform" (
        allowedTokens = ["uniform", "levelset"]
    )
    float step_size = 0
    float threshold = 0
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldGinstance "ArnoldGinstance"
{
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    uint id = 0
    bool inherit_xform = 1
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    float motion_end = 1
    float motion_start = 0
    bool opaque = 1
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar sidedness = 255
    float step_size = 0
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldProcedural "ArnoldProcedural"
{
    string arnold:namespace = ""
    bool auto_instancing = 1
    string data = ""
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    string filename = ""
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    float motion_end = 1
    float motion_start = 0
    bool opaque = 1
    bool override_nodes = 0
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar sidedness = 255
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldListAggregate "ArnoldListAggregate"
{
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    float motion_end = 1
    float motion_start = 0
    bool opaque = 1
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar sidedness = 255
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldVolume "ArnoldVolume"
{
    bool compress = 1
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    uchar[] filedata
    string filename = ""
    string[] grids
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    float motion_end = 1
    float motion_start = 0
    bool opaque = 1
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar sidedness = 255
    float step_scale = 1
    float step_size = 0
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    float velocity_fps = 24
    string[] velocity_grids
    float velocity_outlier_threshold = 0.001
    float velocity_scale = 1
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float volume_padding = 0
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldVolumeImplicit "ArnoldVolumeImplicit"
{
    bool compress = 1
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    string field_channel = "field"
    uchar[] filedata
    string filename = ""
    string[] grids
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    vector3f max = (0, 0, 0)
    vector3f min = (0, 0, 0)
    float motion_end = 1
    float motion_start = 0
    bool opaque = 1
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float ray_bias = 0.000001
    bool receive_shadows = 1
    uint samples = 10
    bool self_shadows = 1
    uchar sidedness = 255
    token solver = "uniform" (
        allowedTokens = ["uniform", "levelset"]
    )
    float step_scale = 1
    float step_size = 0
    float threshold = 0
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    float velocity_fps = 24
    string[] velocity_grids
    float velocity_outlier_threshold = 0.001
    float velocity_scale = 1
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldInstancer "ArnoldInstancer"
{
    string arnold:namespace = ""
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    uint id = 0
    matrix4d[] instance_matrix
    uchar[] instance_visibility
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    float motion_end = 1
    float motion_start = 0
    uint[] node_idxs
    bool opaque = 1
    bool override_nodes = 0
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar sidedness = 255
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldColorManagerOcio "ArnoldColorManagerOcio"
{
    string color_space_linear = ""
    string color_space_narrow = ""
    string config = ""
    float[] linear_chromaticities
}

class ArnoldMaterialx "ArnoldMaterialx"
{
    bool assign_materials = 1
    bool assign_properties = 1
    token assign_type = "look" (
        allowedTokens = ["look", "material"]
    )
    bool assign_visibilities = 1
    bool enable = 1
    string filename = ""
    string look = ""
    string selection = ""
}

class ArnoldMerge "ArnoldMerge"
{
    bool enable = 1
}

class ArnoldSetParameter "ArnoldSetParameter"
{
    string[] assignment
    bool enable = 1
    bool[] enable_assignment
    string selection = ""
}

class ArnoldDisable "ArnoldDisable"
{
    bool enable = 1
    bool lights = 1
    token mode = "disable" (
        allowedTokens = ["disable", "enable"]
    )
    bool operators = 1
    string selection = ""
    bool shaders = 1
    bool shapes = 1
}

class ArnoldSwitchOperator "ArnoldSwitchOperator"
{
    bool enable = 1
    int index = 0
}

class ArnoldSetTransform "ArnoldSetTransform"
{
    bool enable = 1
    token mode = "append" (
        allowedTokens = ["append", "replace"]
    )
    vector3f rotate = (0, 0, 0)
    token rotate_order = "xyz" (
        allowedTokens = ["xyz", "xzy", "yxz", "yzx", "zxy", "zyx"]
    )
    vector3f scale = (1, 1, 1)
    string selection = ""
    token transform_order = "srt" (
        allowedTokens = ["srt", "str", "tsr", "trs", "rst", "rts"]
    )
    vector3f translate = (0, 0, 0)
}

class ArnoldCollection "ArnoldCollection"
{
    string collection = ""
    bool enable = 1
    string selection = ""
}

class ArnoldIncludeGraph "ArnoldIncludeGraph"
{
    bool enable = 1
    string filename = ""
    string target = ""
}

class ArnoldStringReplace "ArnoldStringReplace"
{
    bool enable = 1
    string match = ""
    token os = "any" (
        allowedTokens = ["any", "os_linux", "windows", "mac"]
    )
    string replace = ""
    string selection = ""
}

class ArnoldAlembic "ArnoldAlembic"
{
    string arnold:namespace = ""
    bool exclude_xform = 0
    bool expand_hidden = 0
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    string filename = ""
    bool flip_v = 0
    float fps = 24
    float frame = 0
    uint id = 0
    bool invert_normals = 0
    string[] layers
    bool make_instance = 0
    string material_attribute = ""
    matrix4d[] matrix
    bool matte = 0
    float motion_end = 1
    float motion_start = 0
    string nameprefix = ""
    string objectpath = ""
    bool opaque = 1
    bool override_nodes = 0
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    bool pull_user_params = 0
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    string radius_attribute = ""
    float radius_default = 0.02
    float radius_scale = 1
    float ray_bias = 0.000001
    bool receive_shadows = 1
    string scene_camera = ""
    bool self_shadows = 1
    float shutter_end = 0
    float shutter_start = 0
    uchar sidedness = 255
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_instance_cache = 1
    bool use_light_group = 0
    bool use_shadow_group = 0
    bool velocity_ignore = 0
    float velocity_scale = 1
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    bool visibility_ignore = 0
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

class ArnoldCryptomatteFilter "ArnoldCryptomatteFilter"
{
    token filter = "gaussian" (
        allowedTokens = ["gaussian", "blackman_harris", "triangle", "box", "disk", "cone"]
    )
    bool noop = 0
    int rank = -1
    float width = 2
}

class ArnoldCryptomatteManifestDriver "ArnoldCryptomatteManifestDriver"
{
    string filename = "dummy.json"
}

class ArnoldUsd "ArnoldUsd"
{
    string arnold:namespace = ""
    bool debug = 0
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric\r
        extent of the authored gprim in its own local space (i.e. its own\r
        transform not applied), without accounting for any shader-induced\r
        displacement.  Whenever any geometry-affecting attribute is authored\r
        for any gprim in a layer, extent must also be authored at the same\r
        timesample; failure to do so will result in incorrect bounds-computation.\r
        \\sa \\ref UsdGeom_Boundable_Extent.\r
        \r
        An authored extent on a prim which has children is expected to include\r
        the extent of all children, as they will be pruned from BBox computation\r
        during traversal."""
    )
    string filename = ""
    float frame = 0
    uint id = 0
    bool invert_normals = 0
    matrix4d[] matrix
    bool matte = 0
    float motion_end = 1
    float motion_start = 0
    string object_path = ""
    bool opaque = 1
    bool override_nodes = 0
    string[] overrides
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a\r
        prim whose purpose is "render" to its (single target)\r
        purpose="proxy" prim.  This is entirely optional, but can be\r
        useful in several scenarios:\r
        \r
        - In a pipeline that does pruning (for complexity management)\r
        by deactivating prims composed from asset references, when we\r
        deactivate a purpose="render" prim, we will be able to discover\r
        and additionally deactivate its associated purpose="proxy" prim,\r
        so that preview renders reflect the pruning accurately.\r
        \r
        - DCC importers may be able to make more aggressive optimizations\r
        for interactive processing and display if they can discover the proxy\r
        for a given render prim.\r
        \r
        - With a little more work, a Hydra-based application will be able\r
        to map a picked proxy prim back to its render geometry for selection.\r
\r
        \\note It is only valid to author the proxyPrim relationship on\r
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = '''Purpose is a concept we have found useful in our pipeline for \r
        classifying geometry into categories that can each be independently\r
        included or excluded from traversals of prims on a stage, such as\r
        rendering or bounding-box computation traversals.  The fallback\r
        purpose, default indicates that a prim has "no special purpose"\r
        and should generally be included in all traversals.  Subtrees rooted\r
        at a prim with purpose render should generally only be included\r
        when performing a "final quality" render.  Subtrees rooted at a prim\r
        with purpose proxy should generally only be included when \r
        performing a lightweight proxy render (such as openGL).  Finally,\r
        subtrees rooted at a prim with purpose guide should generally\r
        only be included when an interactive application has been explicitly\r
        asked to "show guides". \r
        \r
        In the previous paragraph, when we say "subtrees rooted at a prim",\r
        we mean the most ancestral or tallest subtree that has an authored,\r
        non-default opinion.  If the purpose of </RootPrim> is set to \r
        "render", then the effective purpose of </RootPrim/ChildPrim> will\r
        be "render" even if that prim has a different authored value for\r
        purpose.  <b>See ComputePurpose() for details of how purpose \r
        inherits down namespace</b>.\r
        \r
        As demonstrated in UsdGeomBBoxCache, a traverser should be ready to \r
        accept combinations of included purposes as an input.\r
        \r
        Purpose render can be useful in creating "light blocker"\r
        geometry for raytracing interior scenes.  Purposes render and\r
        proxy can be used together to partition a complicated model\r
        into a lightweight proxy representation for interactive use, and a\r
        fully realized, potentially quite heavy, representation for rendering.\r
        One can use UsdVariantSets to create proxy representations, but doing\r
        so requires that we recompose parts of the UsdStage in order to change\r
        to a different runtime level of detail, and that does not interact\r
        well with the needs of multithreaded rendering. Purpose provides us with\r
        a better tool for dynamic, interactive complexity management.'''
    )
    float ray_bias = 0.000001
    bool receive_shadows = 1
    bool self_shadows = 1
    uchar sidedness = 255
    int threads = 1
    string[] trace_sets
    token transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool use_light_group = 0
    bool use_shadow_group = 0
    uchar visibility = 255 (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" \r
        visibility that is supported by most DCC apps.  Visibility is \r
        animatable, allowing a sub-tree of geometry to be present for some \r
        segment of a shot, and absent from others; unlike the action of \r
        deactivating geometry prims, invisible geometry is still \r
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the\r
        order in which they should be pushed onto a transform stack while\r
        visiting a UsdStage's prims in a graph traversal that will effect\r
        the desired positioning for this prim and its descendant prims.\r
        \r
        You should rarely, if ever, need to manipulate this attribute directly.\r
        It is managed by the AddXformOp(), SetResetXformStack(), and\r
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and\r
        GetLocalTransformation()."""
    )
}

